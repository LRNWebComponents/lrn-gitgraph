<link rel="import" href="../polymer/polymer.html">
<script src="./libraries/gitgraph.js/src/gitgraph.js"></script>
<link rel="stylesheet" type="text/css" href="./libraries/gitgraph.js/src/gitgraph.css" />
<link rel="import" href="../iron-ajax/iron-ajax.html">

<!--
`lrn-gitgraph`
A LRN element

@demo demo/index.html
-->

<dom-module id="lrn-gitgraph">
  <template>
    <style>
      :host {
        display: block;
        overflow-x: scroll;
      }
    </style>
    <canvas id="gitGraph"></canvas>
  </template>
  <script>
    Polymer({

      is: 'lrn-gitgraph',

      properties: {
        template: {
          type: String,
          value: 'blackarrow',
        },
        orientation: {
          type: String,
          value: 'horizontal'
        },
        mode: {
          type: String,
          value: ''
        },
        reverseArrow: {
          type: Boolean,
          value: false,
        },
        commits: {
          type: Array,
          value: []
        },
        config: {
          type: Object
        }
      },
      observers: [
        '_commitsChanged(commits)'
      ],
      _commitsChanged: function(commits) {
        var root = this;
        if (root.config) {
          if (commits.length > 0) {
            var gitgraph = new GitGraph(root.config);
            var tree = [];
            commits.forEach(function(item) {
              if (item.commits) {
                item.commits.forEach(function(commit) {
                  commit['branch'] = item.branch;
                  tree.push(commit);
                });
              }
            });
            // remove duplicate commits
            tree = root._treeRemoveDuplicates(tree);
            console.log('tree', tree);
            // // sort by date
            // tree.sort(function(a,b) {
            //   return new Date(b.date) - new Date(a.date);
            // });
            // // reverse the tree
            // tree = tree.reverse();
            // identify forks
            // const forks = root._getTreeForks(tree);
            // console.log('forks', forks);
            // // create the commits with gitgraph
            // tree.forEach(function(item, i) {
            //   // first we need to decide what branch we need to make
            //   // the commits on. if it's the first item then we know it's
            //   // on the "master" branch.
            //   if (i === 0) {
            //     gitgraph.branch(item.branch);
            //   }
            //   else {
            //     // if the current branch is different than the one before it
            //     // and the commits are different then we know we have a branch
            //     if (item.branch !== tree[i - 1]. branch) {
            //       if (item.commit !== tree[i - 1].commit) {
            //         // check to see if the branch exists in gitgraph already
            //         var branchExists = false;
            //         gitgraph.branches.forEach(function(b) {
            //           if (b.name === item.name) {
            //             branchExists = true;
            //           }
            //         })
            //         // if the branch does not exist then we need to create it fork it
            //         // from the previous branch
            //         if (!branchExists) {
            //           var prevBranch = gitgraph.checkout(tree[i - 1].branch);
            //           var branch = prevBranch
            //         }
            //       }
            //     }
            //   }
            // });
            // tree.forEach(function(item) {
            //   if (createdBranches.indexOf(item.branch) < 0) {
            //     createdBranches.push(item.branch);
            //   }
            //   var branch = gitgraph.branch(item.branch);
            //   branch.commit({
            //     sha1: item.commit,
            //     message: item.subject
            //   });
            // });
            // console.log(createdBranches);
            // branches = []
            // branches['master'] = gitgraph.branch('master');
            // branches['master'].commit();
            // branches['master'].commit();
            // branches['develop'] = gitgraph.branch('develop');
            // branches['develop'].commit();
            // branches['master'].commit();
          }
        }
      },
      _getTreeForks: function(tree) {
        var forks = [];
        var root = this;
        var existingParents = [];
        var existingCommits = [];
        tree.forEach(function(item) {
          if (existingCommits.includes(item.commit)) {
            return;
          }
          if (existingParents.includes(item.parent)) {
            if (typeof forks[item.parent] === 'undefined') {
              forks[item.parent] = [];
            }
            forks[item.parent] = [item];
          }
          existingParents.push(item.parent);
          existingCommits.push(item.commit);
        });
        return forks;
      },
      _treeRemoveDuplicates: function(tree) {
        var htTree = [];
        var htCommits = [];
        tree.forEach(function(t) {
          if (!htCommits.includes(t.commit)) {
            htTree.push(t);
            htCommits.push(t.commit);
          }
        });
        return htTree;
      },
      _uniqueArray: function(array) {
        var seen = {};
        return array.filter(function(item) {
            return seen.hasOwnProperty(item) ? false : (seen[item] = true);
        });
      },
      ready: function() {
        var root = this;
        var config = {
          template: root.template, // could be: "blackarrow" or "metro" or `myTemplate` (custom Template object)
          reverseArrow: false, // to make arrows point to ancestors, if displayed
          orientation: root.orientation,
          element: root.$$('#gitGraph')
        };
        if (root.mode !== '') {
          config.mode = root.mode;
        }
        root.config = config;
      }
    });
  </script>
</dom-module>
